// Copyright (c) 2020 ChromaWay AB. See README for license information.

package net.postchain.base.data

import net.postchain.base.data.SAPQueryExecutor.executeByteArrayQuery
import net.postchain.core.EContext
import net.postchain.core.TxDetail
import java.sql.Connection

class SAPHanaSQLDatabaseAccess : SQLDatabaseAccess() {

    override fun isSavepointSupported(): Boolean = false

    override fun createSchema(connection: Connection, schema: String) {
        val sql = "CREATE SCHEMA \"$schema\""
        queryRunner.update(connection, sql)
    }

    override fun setCurrentSchema(connection: Connection, schema: String) {
        val sql = "SET SCHEMA \"$schema\""
        queryRunner.update(connection, sql)
    }

    override fun dropSchemaCascade(connection: Connection, schema: String) {
        val sql = "DROP SCHEMA \"$schema\" CASCADE"
        queryRunner.update(connection, sql)
    }

    override fun cmdCreateTableBlocks(ctx: EContext): String {
        return "CREATE TABLE ${tableBlocks(ctx)}" +
                " (block_iid BIGINT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY," +
                "  block_height BIGINT NOT NULL, " +
                "  block_rid VARBINARY(1000)," +
                "  block_header_data BLOB," +
                "  block_witness BLOB," +
                "  timestamp BIGINT," +
                "  UNIQUE (block_rid)," +
                "  UNIQUE (block_height))"
    }

    override fun cmdCreateTableBlockchains(): String {
        return "CREATE TABLE ${tableBlockchains()} " +
                " (chain_iid BIGINT, blockchain_rid VARBINARY(1000) NOT NULL)"
    }

    override fun cmdCreateTableTransactions(ctx: EContext): String {
        return "CREATE TABLE ${tableTransactions(ctx)} (" +
                "    tx_iid BIGINT NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, " +
                "    tx_rid VARBINARY(1000) NOT NULL," +
                "    tx_data BLOB NOT NULL," +
                "    tx_hash VARBINARY(1000) NOT NULL," +
                "    block_iid BIGINT NOT NULL REFERENCES ${tableBlocks(ctx)}(block_iid)," +
                "    UNIQUE (tx_rid))"
    }

    override fun cmdCreateTableConfigurations(ctx: EContext): String {
        return "CREATE TABLE ${tableConfigurations(ctx)} (" +
                "height BIGINT PRIMARY KEY" +
                ", configuration_data BLOB NOT NULL" +
                ")"
    }

    override fun cmdCreateTablePeerInfos(): String {
        return "CREATE TABLE ${tablePeerinfos()} (" +
                " $TABLE_PEERINFOS_FIELD_HOST VARCHAR(255) NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_PORT BIGINT NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_PUBKEY VARCHAR(255) NOT NULL" +
                ", $TABLE_PEERINFOS_FIELD_TIMESTAMP TIMESTAMP NOT NULL" +
                ")"
    }

    override fun cmdCreateTableBlockchainReplicas(): String {
        return "CREATE TABLE ${tableBlockchainReplicas()} (" +
                ", $TABLE_REPLICAS_FIELD_BRID text NOT NULL" +
                ", $TABLE_REPLICAS_FIELD_PUBKEY text NOT NULL" +
                ", PRIMARY KEY ($TABLE_REPLICAS_FIELD_BRID, $TABLE_REPLICAS_FIELD_PUBKEY))"
    }

    override fun cmdCreateTableMustSyncUntil(): String {
        return "CREATE TABLE ${tableMustSyncUntil()} (" +
                " $TABLE_SYNC_UNTIL_FIELD_CHAIN_IID text PRIMARY KEY NOT NULL REFERENCES ${tableBlockchains()} (chain_iid)" +
                ", $TABLE_SYNC_UNTIL_FIELD_HEIGHT BIGINT NOT NULL" +
                ")"
    }

    override fun cmdCreateTableMeta(): String {
        return "CREATE TABLE ${tableMeta()} (key VARCHAR(255) PRIMARY KEY, value VARCHAR(1000))"
    }

    override fun cmdCreateTableGtxModuleVersion(ctx: EContext): String {
        return "CREATE TABLE ${tableGtxModuleVersion(ctx)} (module_name VARCHAR(1000) PRIMARY KEY, version BIGINT NOT NULL)"
    }

    override fun cmdInsertBlocks(ctx: EContext): String {
        return "INSERT INTO ${tableBlocks(ctx)} (block_height) VALUES (?) "
    }

    override fun cmdInsertTransactions(ctx: EContext): String {
        return "INSERT INTO ${tableTransactions(ctx)} (tx_rid, tx_data, tx_hash, block_iid) " +
                "VALUES (?, ?, ?, ?) "
    }

    override fun cmdInsertConfiguration(ctx: EContext): String {
        return "UPSERT ${tableConfigurations(ctx)} (height, configuration_data) VALUES (?, ?) "
    }

    override fun getBlockHeader(ctx: EContext, blockRID: ByteArray): ByteArray {
        val sql = "SELECT block_header_data FROM ${tableBlocks(ctx)} WHERE block_rid = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setBytes(1, blockRID)
        } ?: byteArrayOf()
    }

    override fun getBlockTransactions(ctx: EContext, blockRID: ByteArray, hashesOnly: Boolean): List<TxDetail> {
        val sql = """
            SELECT tx_rid, tx_hash${if (hashesOnly) "" else ", tx_data"}
            FROM ${tableTransactions(ctx)} t
            JOIN ${tableBlocks(ctx)} b ON t.block_iid=b.block_iid
            WHERE b.block_rid = ?
            ORDER BY tx_iid
        """.trimIndent()

        val statement = ctx.conn.prepareStatement(sql)
                .apply {
                    setBytes(1, blockRID)
                }

        val resultSet = statement.executeQuery()

        val txs = mutableListOf<TxDetail>()
        while (resultSet.next()) {
            txs.add(TxDetail(
                    resultSet.getBlob(1).binaryStream.readBytes(),
                    resultSet.getBlob(2).binaryStream.readBytes(),
                    if (hashesOnly) null else resultSet.getBlob(3).binaryStream.readBytes()
            ))
        }

        return txs
    }

    override fun getWitnessData(ctx: EContext, blockRID: ByteArray): ByteArray {
        val sql = "SELECT block_witness FROM ${tableBlocks(ctx)} WHERE block_rid = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setBytes(1, blockRID)
        } ?: byteArrayOf()
    }

    override fun getTxBytes(ctx: EContext, txRID: ByteArray): ByteArray? {
        val sql = "SELECT tx_data FROM ${tableTransactions(ctx)} WHERE tx_rid = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setBytes(1, txRID)
        } ?: byteArrayOf()
    }

    override fun getConfigurationData(ctx: EContext, height: Long): ByteArray? {
        val sql = "SELECT configuration_data FROM ${tableConfigurations(ctx)} WHERE height = ?"

        return executeByteArrayQuery(ctx, sql) {
            it.setLong(1, height)
        }
    }
}